// ───────── Fluxion DSL Grammar (Complete) ─────────

// Whitespace & comments
WS: /[ \t\f]+/
%ignore WS

COMMENT_SLASH: /\/\/[^\n]*/
COMMENT_HASH : /#[^\n]*/
%ignore COMMENT_SLASH
%ignore COMMENT_HASH

// Newlines (CRLF / LF)
NL: /(\r?\n)+/

// Tokens
IDENT: /[A-Za-z_][A-Za-z0-9_\-]*/
EQUAL: "="
COLON: ":"
ARROW: "=>"
COMMA: ","
LE: "<="
GE: ">="
EQEQ: "=="
NOTEQ: "!="
NULLISH_OP: "??"
AND_OP: "&&"
OR_OP: "||"
PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
PERCENT: "%"
NOT: "!"
LT: "<"
GT: ">"
QMARK: "?"

// Strings: double-quoted with escapes
DQSTRING: /"([^"\\]|\\.)*"/

// Numbers: int / float / sci
NUMBER: /-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/

// Entry point
start: script?

// Script = optional leading/trailing newlines around statements
script: script_ws? statement (script_ws statement)* script_ws?

script_ws: NL+

// Statements
?statement: assign
         | return_
         | if_
         | for_
         | func
         | command
         | expr_stmt
         | reassign

// let name = expr
assign: "let" IDENT "=" expr

// name = expr (reassignment)
reassign: IDENT "=" expr

// return expr
return_: "return" expr?

// if (cond) { ... } else { ... }
if_: "if" "(" expr ")" block ("else" (block | if_))?

// for name in expr { ... }
for_: "for" IDENT "in" expr block

// func name(params) { ... }
func: ("func" | "fn") IDENT "(" param_list? ")" block
param_list: IDENT ("," IDENT)*

// Block of statements
block: "{" script? "}"

// Expression as statement
expr_stmt: expr

// Command: NAME { key: value, ... } or inline key=value pairs
command: IDENT NL? command_args

command_args: map
             | inline_command_args

inline_command_args: keyval (COMMA script_ws? keyval)*

// Expressions with precedence
?expr: ternary

?ternary: logical_or (QMARK expr COLON expr)?

logical_or: logical_and (OR_OP logical_and)*

logical_and: equality (AND_OP equality)*

equality: comparison ((EQEQ | NOTEQ) comparison)*

comparison: nullish_coalesce ((LT | GT | LE | GE) nullish_coalesce)*

nullish_coalesce: additive (NULLISH_OP additive)*

additive: multiplicative ((PLUS | MINUS) multiplicative)*

multiplicative: unary ((STAR | SLASH | PERCENT) unary)*

?unary: (NOT | MINUS | PLUS) unary
      | postfix

?postfix: primary ("." IDENT)*

?primary: call
        | get_chain
        | var
        | dqstring
        | number
        | list
        | map
        | "(" expr ")"
        | "true"  -> true_
        | "false" -> false_
        | "null"  -> null_
        | "nil"   -> null_

// Function call
call: IDENT "(" script_ws? arg_expr_list? ")"
arg_expr_list: expr (COMMA script_ws? expr)* (COMMA script_ws?)?

// Property access chain
get_chain: IDENT ("." IDENT)+

// Variable reference
var: IDENT

// Literals
dqstring: DQSTRING
number: NUMBER

// Collections
list: "[" list_ws? list_items? list_ws? "]"
list_ws: NL+
list_items: expr ("," list_ws? expr)* ("," list_ws?)?

map:  "{" list_ws? map_items? list_ws? "}"
map_items: keyval ("," list_ws? keyval)* ("," list_ws?)?

keyval: (IDENT | DQSTRING) (":" | "=") expr

// Booleans and null
true_: "true"
false_: "false"
null_: "null" | "nil"
