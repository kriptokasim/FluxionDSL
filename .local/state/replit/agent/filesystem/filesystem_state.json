{"file_contents":{"tests/test_parse.py":{"content":"from fluxion.core.parser import parse\n\ndef test_parse_min():\n    SRC = 'echo value=\"hi\"'\n    ast = parse(SRC)\n    assert isinstance(ast, list) and len(ast) == 1\n","size_bytes":161},"pyproject.toml":{"content":"[build-system]\nrequires = [\"setuptools>=68\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"fluxion\"\nversion = \"2.2.0\"\ndescription = \"Fluxion DSL (minimal) — parser + runtime\"\nauthors = [{name=\"You\"}]\nrequires-python = \">=3.10\"\ndependencies = [\n  \"lark>=1.1.7\",\n  \"requests>=2.31.0\",\n  \"pyyaml>=6.0.1\",\n  \"rich>=13.7.0\",\n  \"pytest>=8.4.2\",\n]\n\n[project.scripts]\nfluxion = \"fluxion.cli:main\"\n","size_bytes":413},"tests/test_eval.py":{"content":"from fluxion.runtime.runner_v2 import RunnerV2\n\ndef test_eval_interpolation():\n    r = RunnerV2()\n    res = r.run_text('echo value=\"X={{1}}\"')\n    assert 'vars' in res\n    assert res['vars']['_last_command']['args']['value'] == \"X=1\"\n","size_bytes":234},"fluxion/core/parser.py":{"content":"from __future__ import annotations\nfrom pathlib import Path\nfrom lark import Lark, Transformer, v_args, Tree, Token\nfrom lark.exceptions import GrammarError\nimport re\n\n_GRAMMAR = (Path(__file__).parents[1] / \"grammar\" / \"fluxion.lark\").read_text(encoding=\"utf-8\")\n\n\nclass Node:\n    def __init__(self, typ, **kw):\n        self.typ = typ\n        self.__dict__.update(kw)\n    def __repr__(self):\n        return f\"Node({self.typ}, {self.__dict__})\"\n\n\n# -----------------------------\n# Desugar helpers\n# -----------------------------\n\n_CMD_NAME_RE = re.compile(r\"^[A-Za-z_][A-Za-z0-9_]*$\")\n_LEADING_CMD_RE = re.compile(r\"^(\\s*)([A-Za-z_][A-Za-z0-9_]*)\\b(.*)$\")\n\ndef _balanced_split_commas(s: str) -> list[str]:\n    \"\"\"Virgülleri yalnızca { } [ ] ( ) ve tırnaklar DENGELİ iken böl.\n       Çift ve tek tırnak, kaçış, parantez/brace/braceket dengesi gözetilir.\"\"\"\n    out, buf = [], []\n    st_paren = st_brack = st_brace = 0\n    in_sq = in_dq = False\n    esc = False\n    for ch in s:\n        if esc:\n            buf.append(ch); esc = False; continue\n        if ch == \"\\\\\":\n            buf.append(ch); esc = True; continue\n        if in_sq:\n            buf.append(ch)\n            if ch == \"'\": in_sq = False\n            continue\n        if in_dq:\n            buf.append(ch)\n            if ch == '\"': in_dq = False\n            continue\n\n        if ch == \"'\": in_sq = True; buf.append(ch); continue\n        if ch == '\"': in_dq = True; buf.append(ch); continue\n\n        if ch == '(': st_paren += 1\n        elif ch == ')': st_paren -= 1\n        elif ch == '[': st_brack += 1\n        elif ch == ']': st_brack -= 1\n        elif ch == '{': st_brace += 1\n        elif ch == '}': st_brace -= 1\n\n        if ch == ',' and st_paren == st_brack == st_brace == 0:\n            out.append(''.join(buf).strip()); buf = []\n        else:\n            buf.append(ch)\n    if buf:\n        out.append(''.join(buf).strip())\n    return out\n\n\ndef _looks_like_assign_list(s: str) -> bool:\n    # En az bir \"name = expr\" parçası olmalı; sol taraf NAME olmalı\n    parts = _balanced_split_commas(s)\n    ok = False\n    for p in parts:\n        if '=' not in p:\n            return False\n        k, _eq, v = p.partition('=')\n        if not _CMD_NAME_RE.match(k.strip()):\n            return False\n        if not v.strip():\n            return False\n        ok = True\n    return ok\n\n\ndef _desugar_line(line: str) -> str:\n    # fn → func\n    m = re.match(r\"^(\\s*)fn\\b\", line)\n    if m:\n        return line[:m.end(1)] + \"func\" + line[m.end():]\n\n    # Komut argümanlarını { k: v } şekline çevir\n    m = _LEADING_CMD_RE.match(line)\n    if not m:\n        return line\n    indent, head, rest = m.groups()\n\n    # Bazı anahtar kelimeler komut değildir\n    if head in (\"let\", \"return\", \"if\", \"else\", \"for\", \"func\"):\n        return line\n\n    # Eğer rest tamamen boşsa veya brace/paren ile başlıyorsa dokunma\n    if not rest.strip():\n        return line\n    # Zaten '{' ile başlıyorsa komut map formundadır\n    if rest.lstrip().startswith('{'):\n        return line\n\n    # \"CMD k1=expr, k2=expr\" kalıbını yakala\n    # rest tipik olarak: \"  k1=expr, k2=expr\"\n    if _looks_like_assign_list(rest.strip()):\n        # { k1: expr, k2: expr }\n        parts = _balanced_split_commas(rest.strip())\n        pairs = []\n        for p in parts:\n            k, _eq, v = p.partition('=')\n            pairs.append(f\"{k.strip()}: {v.strip()}\")\n        return f\"{indent}{head} {{ \" + \", \".join(pairs) + \" }}\"\n\n    return line\n\n\ndef _desugar(text: str) -> str:\n    lines = text.splitlines()\n    return \"\\n\".join(_desugar_line(ln) for ln in lines)\n\n\n@v_args(inline=True)\nclass BuildAST(Transformer):\n    # roots\n    def start(self, *stmts): return list(stmts)\n    def expr_stmt(self, t):  return t\n\n    # literals\n    def dqstring(self, tok): return Node(\"str\", value=str(tok))\n    def number(self, tok):\n        s = str(tok)\n        return Node(\"num\", value=float(s) if any(c in s for c in \".eE\") else int(s))\n    def var(self, name):     return Node(\"var\", name=str(name))\n\n    # collections\n    def list(self, *xs):     return Node(\"list\", items=list(xs))\n    def pair(self, k, v):    return (str(k), v)\n    def map(self, *pairs):   return Node(\"map\", items=dict(pairs))\n\n    # args\n    def arg_list(self, *pairs):\n        out = []\n        for p in pairs:\n            if isinstance(p, Tree):\n                out.extend(p.children)\n            else:\n                out.append(p)\n        return out\n\n    def keyval(self, k, v):  return (str(k), v)\n\n    def arg_expr_list(self, *exprs):\n        out = []\n        for e in exprs:\n            if isinstance(e, Tree):\n                out.extend(e.children)\n            else:\n                out.append(e)\n        return out\n\n    # statements\n    def assign(self, name, expr): return Node(\"assign\", name=str(name), expr=expr)\n    def return_(self, expr):     return Node(\"return\", expr=expr)\n    def if_(self, cond, then_b, else_b=None): return Node(\"if\", cond=cond, then=then_b or [], else_=else_b or [])\n    def for_(self, name, iterable, block):    return Node(\"for\", var=str(name), iterable=iterable, block=block or [])\n    def func(self, name, params=None, block=None):\n        return Node(\"func\", name=str(name), params=[str(p) for p in (params or [])], block=block or [])\n    def param_list(self, *names): return list(names)\n    def block(self, *stmts):      return list(stmts)\n\n    def command(self, name, args=None):\n        pairs = []\n        if args is None:\n            pairs = []\n        elif isinstance(args, list):\n            pairs = args\n        elif isinstance(args, dict):\n            pairs = list(args.items())\n        elif isinstance(args, Node) and args.typ == \"map\":\n            pairs = list(args.items.items())\n        elif isinstance(args, Tree):\n            tmp = []\n            for ch in args.children:\n                if isinstance(ch, Tree):\n                    tmp.extend(ch.children)\n                else:\n                    tmp.append(ch)\n            if len(tmp) == 1 and isinstance(tmp[0], Node) and getattr(tmp[0], \"typ\", \"\") == \"map\":\n                pairs = list(tmp[0].items.items())\n            else:\n                pairs = tmp\n        norm = []\n        for p in pairs:\n            if isinstance(p, tuple) and len(p) == 2:\n                k, v = p\n                norm.append((str(k), v))\n        return Node(\"command\", name=str(name), args=dict(norm))\n\n    # calls\n    def call(self, name, *rest):\n        if not rest:\n            argv = []\n        elif len(rest) == 1:\n            a = rest[0]\n            if isinstance(a, list):\n                argv = a\n            elif isinstance(a, Tree):\n                argv = list(a.children)\n            else:\n                argv = [a]\n        else:\n            argv = list(rest)\n        return Node(\"call\", name=str(name), args=argv)\n\n    # get chain\n    def get_chain(self, *parts):\n        base = parts[0]\n        for p in parts[1:]:\n            if isinstance(p, Token):\n                base = Node(\"get\", obj=base, name=str(p))\n            else:\n                base = Node(\"get\", obj=base, name=str(p))\n        return base\n\n    def reassign(self, name, expr):\n        return Node('assign', name=str(name), expr=expr)\n\n    def getprop(self, base, name):\n        return Node('getprop', base=base, name=str(name))\n\n\ndef _build_parser():\n    try:\n        return Lark(\n            _GRAMMAR,\n            start=\"start\",\n            parser=\"lalr\",\n            maybe_placeholders=True,\n        )\n    except GrammarError:\n        return Lark(\n            _GRAMMAR,\n            start=\"start\",\n            parser=\"earley\",\n            lexer=\"dynamic_complete\",\n            maybe_placeholders=True,\n        )\n\n\n_PARSER = None\n\ndef parse(text: str):\n    \"\"\"Public parse entry — önce sugar’ı sadeleştir, sonra parse et.\"\"\"\n    global _PARSER\n    if _PARSER is None:\n        _PARSER = _build_parser()\n    text = _desugar(text)\n    tree = _PARSER.parse(text)\n    ast = BuildAST().transform(tree)\n    return ast\n","size_bytes":7989},"fluxion/__init__.py":{"content":"","size_bytes":0},"fluxion/runtime/runner_v2.py":{"content":"# fluxion/runtime/runner_v2.py\nfrom __future__ import annotations\nfrom typing import Any, Dict, List, Optional\nimport json\nfrom lark import Tree\nfrom fluxion.core.parser import parse\n\n# ---------- helpers ----------\nclass _ReturnSignal:\n    def __init__(self, value: Any):\n        self.value = value\n\nScope = Dict[str, Any]\nBOOLS = {\"true\": True, \"false\": False, \"null\": None, \"nil\": None}\n\ndef _as_bool(v: Any) -> bool: return bool(v)\ndef _is_nullish(v: Any) -> bool: return v is None\n\n# ---------- echo interpolation ----------\ndef _interpolate_string(raw: str, scope: Scope) -> str:\n    import re\n    s = raw\n    if len(s) >= 2 and ((s[0] == '\"' and s[-1] == '\"') or (s[0] == \"'\" and s[-1] == \"'\")):\n        s = s[1:-1]\n\n    def repl(m):\n        expr = m.group(1).strip()\n        if expr in BOOLS:\n            v = BOOLS[expr]; return \"\" if v is None else str(v)\n        if expr in scope:\n            v = scope[expr]; return \"\" if v is None else str(v)\n        try:\n            return str(int(expr))\n        except Exception:\n            pass\n        try:\n            return str(float(expr))\n        except Exception:\n            pass\n        v = scope.get(expr)\n        return \"\" if v is None else str(v)\n\n    return re.sub(r\"\\{\\{([^}]+)\\}\\}\", repl, s)\n\ndef _make_echo(scope: Scope):\n    def _echo(**kwargs):\n        cooked = {k: (_interpolate_string(v, scope) if isinstance(v, str) else v)\n                  for k, v in kwargs.items()}\n        scope[\"_last_command\"] = {\"name\": \"echo\", \"args\": cooked}\n        return None\n    return _echo\n\n# ---------- stdlib ----------\ndef jsonify(obj: Any = None, **kwargs):\n    if obj is not None and kwargs:\n        return json.dumps({\"_\": obj, **kwargs}, ensure_ascii=False)\n    if obj is not None:\n        return json.dumps(obj, ensure_ascii=False)\n    return json.dumps(kwargs, ensure_ascii=False)\n\ndef join(*args): return \"\".join(str(a) for a in args)\n\ndef http_head(_url: str) -> Dict[str, Any]:\n    return {\"ok\": False, \"status\": 0, \"elapsed_ms\": 0, \"length\": 0, \"headers\": {}}\n\ndef http_get(_url: str) -> Dict[str, Any]:\n    return {\"ok\": False, \"status\": 0, \"elapsed_ms\": 0, \"length\": 0, \"text_preview\": \"\"}\n\nSTDLIB_FUNCS = {\n    \"jsonify\": jsonify,\n    \"join\": join,\n    \"http_head\": http_head,\n    \"http_get\": http_get,\n    # echo scope’a enjekte ediliyor\n}\n\n# ---------- invocation plumbing ----------\ndef _invoke_function(fname: str, args_pos: List[Any], args_kw: Dict[str, Any], scope: Scope) -> Any:\n    fn = scope.get(\"__funcs__\", {}).get(fname)\n    if callable(fn):\n        try:\n            return fn(*args_pos, **args_kw) if args_kw else fn(*args_pos)\n        except TypeError:\n            return fn(*args_pos)\n\n    fn = scope.get(\"__stdlib__\", {}).get(fname)\n    if callable(fn):\n        try:\n            return fn(*args_pos, **args_kw) if args_kw else fn(*args_pos)\n        except TypeError:\n            return fn(*args_pos)\n\n    return None\n\ndef _collect_call_args(node_or_tree: Any, scope: Scope) -> (str, List[Any], Dict[str, Any]):\n    \"\"\"\n    BuildAST Node(call/command) ya da Lark Tree(call) alır.\n    Farklı üreticiler için hem positional hem keyword varyantlarını toparlar.\n    \"\"\"\n    # BuildAST Node\n    typ = getattr(node_or_tree, \"typ\", None)\n    if typ in (\"call\", \"command\"):\n        fname = getattr(node_or_tree, \"name\", \"\")\n        pos: List[Any] = []\n        kw: Dict[str, Any] = {}\n\n        # 1) Yaygın: args (list | Tree | dict)\n        if hasattr(node_or_tree, \"args\"):\n            a = getattr(node_or_tree, \"args\")\n            if isinstance(a, list):\n                pos = [_eval_any(x, scope) for x in a]\n            elif isinstance(a, Tree):\n                pos = [_eval_any(x, scope) for x in (a.children or [])]\n            elif isinstance(a, dict):\n                for k, v in a.items():\n                    kw[k] = _eval_any(v, scope)\n\n        # 2) Tekli arg: arg\n        if hasattr(node_or_tree, \"arg\"):\n            pos.append(_eval_any(getattr(node_or_tree, \"arg\"), scope))\n\n        # 3) Bazı build’ler: params / arguments\n        if hasattr(node_or_tree, \"params\"):\n            p = getattr(node_or_tree, \"params\")\n            if isinstance(p, list):\n                pos.extend(_eval_any(x, scope) for x in p)\n        if hasattr(node_or_tree, \"arguments\"):\n            p = getattr(node_or_tree, \"arguments\")\n            if isinstance(p, list):\n                pos.extend(_eval_any(x, scope) for x in p)\n\n        # 4) kwargs (dict)\n        if hasattr(node_or_tree, \"kwargs\") and isinstance(node_or_tree.kwargs, dict):\n            for k, v in node_or_tree.kwargs.items():\n                kw[k] = _eval_any(v, scope)\n\n        return fname, pos, kw\n\n    # Lark Tree(call)\n    if isinstance(node_or_tree, Tree) and node_or_tree.data == \"call\":\n        if not node_or_tree.children:\n            return \"\", [], {}\n        fname = str(node_or_tree.children[0])\n        pos_nodes = node_or_tree.children[1:]\n        pos = [_eval_any(a, scope) for a in pos_nodes]\n        return fname, pos, {}\n\n    return \"\", [], {}\n\n# ---------- evaluator ----------\ndef _eval_any(node: Any, scope: Scope) -> Any:\n    t = getattr(node, \"typ\", None)\n    if t:\n        if t == \"num\":  return node.value\n        if t == \"str\":  return _interpolate_string(node.value, scope)\n        if t == \"var\":\n            name = node.name\n            if name in BOOLS: return BOOLS[name]\n            return scope.get(name)\n        if t == \"list\":\n            return [_eval_any(x, scope) for x in node.items]\n        if t == \"map\":\n            return {k: _eval_any(v, scope) for k, v in node.items.items()}\n        if t in (\"call\", \"command\"):\n            fname, pos, kw = _collect_call_args(node, scope)\n            return _invoke_function(fname, pos, kw, scope) if fname else None\n        return None\n\n    if isinstance(node, Tree):\n        return _eval_tree(node, scope)\n\n    return node\n\ndef _eval_tree(t: Tree, scope: Scope) -> Any:\n    typ = t.data\n\n    # üst sarmalayıcılar\n    if typ in (\"program\", \"start\", \"stmts\", \"statements\", \"block\"):\n        last = None\n        for ch in t.children:\n            r = _eval_tree(ch, scope)\n            if isinstance(r, _ReturnSignal): return r\n            if r is not None: last = r\n        return last\n\n    if typ == \"stmt\":\n        return _exec_stmt(t.children[0], scope) if t.children else None\n\n    # expr ağaçları\n    if typ == \"coalesce\":\n        val = _eval_any(t.children[0], scope); i = 1\n        while i < len(t.children):\n            rhs = _eval_any(t.children[i + 1], scope)\n            if not _is_nullish(val): return val\n            val = rhs; i += 2\n        return val\n\n    if typ == \"or_expr\":\n        val = _eval_any(t.children[0], scope); i = 1\n        while i < len(t.children):\n            rhs = _eval_any(t.children[i + 1], scope)\n            if _as_bool(val): return True\n            val = _as_bool(val) or _as_bool(rhs); i += 2\n        return val\n\n    if typ == \"and_expr\":\n        val = _eval_any(t.children[0], scope); i = 1\n        while i < len(t.children):\n            rhs = _eval_any(t.children[i + 1], scope)\n            if not _as_bool(val): return False\n            val = _as_bool(val) and _as_bool(rhs); i += 2\n        return val\n\n    if typ == \"compare\":\n        left = _eval_any(t.children[0], scope); i = 1\n        while i < len(t.children):\n            op = str(t.children[i]); right = _eval_any(t.children[i + 1], scope)\n            if   op == \"==\": ok = (left == right)\n            elif op == \"!=\": ok = (left != right)\n            elif op == \"<\":  ok = (left <  right)\n            elif op == \"<=\": ok = (left <= right)\n            elif op == \">\":  ok = (left >  right)\n            elif op == \">=\": ok = (left >= right)\n            else: raise RuntimeError(f\"Unknown compare op: {op}\")\n            if not ok: return False\n            left = right; i += 2\n        return True\n\n    if typ == \"sum\":\n        val = _eval_any(t.children[0], scope); i = 1\n        while i + 1 < len(t.children):\n            op = str(t.children[i]); rhs = _eval_any(t.children[i + 1], scope)\n            if   op == \"+\": val = val + rhs\n            elif op == \"-\": val = val - rhs\n            i += 2\n        return val\n\n    if typ == \"term\":\n        val = _eval_any(t.children[0], scope); i = 1\n        while i + 1 < len(t.children):\n            op = str(t.children[i]); rhs = _eval_any(t.children[i + 1], scope)\n            if   op == \"*\": val = val * rhs\n            elif op == \"/\": val = val / rhs\n            elif op == \"%\": val = val % rhs\n            i += 2\n        return val\n\n    if typ == \"factor\" and len(t.children) == 2 and str(t.children[0]) == \"-\":\n        return -_eval_any(t.children[1], scope)\n\n    if typ in (\"expr\", \"atom\"):\n        if len(t.children) == 1:\n            return _eval_any(t.children[0], scope)\n        return _eval_any(t.children[-2], scope)\n\n    if typ == \"call\":\n        fname, pos, kw = _collect_call_args(t, scope)\n        return _invoke_function(fname, pos, kw, scope) if fname else None\n\n    if t.children:\n        return _eval_any(t.children[0], scope)\n    return None\n\ndef _exec_block(stmts: List[Any], scope: Scope) -> Optional[Any]:\n    for s in stmts:\n        r = _exec_stmt(s, scope)\n        if isinstance(r, _ReturnSignal):\n            return r\n    return None\n\ndef _exec_stmt(stmt: Any, scope: Scope) -> Optional[Any]:\n    if isinstance(stmt, Tree) and getattr(stmt, \"data\", None) == \"stmt\":\n        return _eval_tree(stmt, scope)\n\n    t = getattr(stmt, \"typ\", None)\n\n    if t == \"assign\":\n        scope[stmt.name] = _eval_any(stmt.expr, scope)\n        return None\n\n    if t == \"return\":\n        val = _eval_any(stmt.expr, scope)\n        scope[\"__return__\"] = val\n        return _ReturnSignal(val)\n\n    if t == \"if\":\n        cond = _eval_any(stmt.cond, scope)\n        if _as_bool(cond):\n            return _exec_block(stmt.then_block, scope)\n        elif stmt.else_block:\n            return _exec_block(stmt.else_block, scope)\n        return None\n\n    if t == \"for\":\n        it = _eval_any(stmt.iterable, scope)\n        if it is None: return None\n        for v in it:\n            scope[stmt.var] = v\n            r = _exec_block(stmt.body, scope)\n            if isinstance(r, _ReturnSignal):\n                return r\n        return None\n\n    if t == \"func\":\n        fname = stmt.name\n        params = stmt.params or []\n        body = stmt.block or []\n        def _fn_impl(*args, **kwargs):\n            child: Scope = {}\n            child[\"__funcs__\"]  = scope.get(\"__funcs__\", {})\n            child[\"__stdlib__\"] = scope.get(\"__stdlib__\", {})\n            for i, p in enumerate(params):\n                child[p] = args[i] if i < len(args) else kwargs.get(p)\n            r = _exec_block(body, child)\n            if isinstance(r, _ReturnSignal):\n                return r.value\n            return child.get(\"__return__\", None)\n        funcs = dict(scope.get(\"__funcs__\", {}))\n        funcs[fname] = _fn_impl\n        scope[\"__funcs__\"] = funcs\n        return None\n\n    if t in (\"call\", \"command\"):\n        fname, pos, kw = _collect_call_args(stmt, scope)\n        return _invoke_function(fname, pos, kw, scope) if fname else None\n\n    if isinstance(stmt, Tree):\n        return _eval_tree(stmt, scope)\n\n    return None\n\n# ---------- Runner ----------\nclass RunnerV2:\n    def run_text(self, text: str, variables: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        scope: Scope = {}\n        if variables: scope.update(variables)\n\n        scope[\"__stdlib__\"] = dict(STDLIB_FUNCS)\n        scope[\"__stdlib__\"][\"echo\"] = _make_echo(scope)\n        scope[\"__funcs__\"] = dict(scope.get(\"__funcs__\", {}))\n\n        ast = parse(text)\n        if not isinstance(ast, list):\n            ast = [ast]\n\n        ret_val: Any = None\n        for stmt in ast:\n            r = _eval_tree(stmt, scope) if isinstance(stmt, Tree) else _exec_stmt(stmt, scope)\n            if isinstance(r, _ReturnSignal):\n                ret_val = r.value\n                break\n\n        if ret_val is None:\n            ret_val = scope.get(\"__return__\", None)\n\n        vars_out = {k: v for k, v in scope.items() if not k.startswith(\"__\")}\n        return {\"return\": ret_val, \"vars\": vars_out}\n\n    def run_file(self, path: str, variables: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            text = f.read()\n        return self.run_text(text, variables or {})\n","size_bytes":12354},"fluxion/stdlib.py":{"content":"from __future__ import annotations\nimport time, json\nfrom typing import Any, Dict, Optional\nimport requests\n\ndef _to_headers(h: Optional[Dict[str, Any]]):\n    if not h: return {}\n    # stringleştir\n    return {str(k): str(v) for k, v in h.items()}\n\ndef http_get(url: str, headers: Optional[Dict[str, Any]] = None, timeout: float = 10.0) -> Dict[str, Any]:\n    t0 = time.perf_counter()\n    try:\n        r = requests.get(url, headers=_to_headers(headers), timeout=timeout, allow_redirects=True)\n        body = r.text if r.encoding else r.content[:4096].decode(errors=\"replace\")\n        return {\n            \"ok\": r.ok,\n            \"status\": r.status_code,\n            \"length\": len(r.content),\n            \"elapsed_ms\": int((time.perf_counter() - t0) * 1000),\n            \"headers\": dict(r.headers),\n            \"text_preview\": body[:512],\n            \"url\": r.url,\n        }\n    except Exception as e:\n        return {\"ok\": False, \"error\": str(e), \"elapsed_ms\": int((time.perf_counter() - t0) * 1000), \"url\": url}\n\ndef http_head(url: str, headers: Optional[Dict[str, Any]] = None, timeout: float = 10.0) -> Dict[str, Any]:\n    t0 = time.perf_counter()\n    try:\n        r = requests.head(url, headers=_to_headers(headers), timeout=timeout, allow_redirects=True)\n        return {\n            \"ok\": r.ok,\n            \"status\": r.status_code,\n            \"elapsed_ms\": int((time.perf_counter() - t0) * 1000),\n            \"headers\": dict(r.headers),\n            \"url\": r.url,\n        }\n    except Exception as e:\n        return {\"ok\": False, \"error\": str(e), \"elapsed_ms\": int((time.perf_counter() - t0) * 1000), \"url\": url}\n\ndef sleep(sec: float) -> int:\n    time.sleep(max(0.0, float(sec)))\n    return int(sec)\n\ndef join(a: Any, b: Any) -> str:\n    # kolay string birleştirme (DSL içinde \"http://\" + host + \"/x\" vs.)\n    return str(a) + str(b)\n\ndef oast_http_ping(base_host: str, token: str) -> Dict[str, Any]:\n    \"\"\"\n    Basit HTTP ping OAST — DNS tetiklemek için base_host altında HTTP GET atar.\n    Örn: http://<oast>/t/<token>?r=123\n    \"\"\"\n    url = f\"http://{base_host.strip('/')}/t/{token}\"\n    return http_get(url)\n\ndef jsonify(obj: Any) -> str:\n    try:\n        return json.dumps(obj, ensure_ascii=False)  # DSL çıktısında debug için\n    except Exception as e:\n        return f\"<json-error: {e}>\"\n\n# export edilecek tablo\nFUNCS: Dict[str, Any] = {\n    \"http_get\": http_get,\n    \"http_head\": http_head,\n    \"sleep\": sleep,\n    \"join\": join,\n    \"oast_http_ping\": oast_http_ping,\n    \"jsonify\": jsonify,\n}\n","size_bytes":2523},"tests/test_runner_smoke.py":{"content":"from fluxion.runtime.runner_v2 import RunnerV2\n\nSRC = \"\"\"\nfn inc(a) { return a + 1 }\nlet x = 3\nlet y = inc(x)\nreturn y\n\"\"\"\n\ndef test_smoke():\n    r = RunnerV2()\n    out = r.run_text(SRC)\n    assert out.get('return') == 4\n","size_bytes":221},"fluxion/core/__init__.py":{"content":"","size_bytes":0},"fluxion/runtime/__init__.py":{"content":"","size_bytes":0},"fluxion/cli.py":{"content":"# fluxion/cli.py\nfrom __future__ import annotations\nimport argparse, json, sys\nfrom fluxion.runtime.runner_v2 import RunnerV2\n\ndef _json_default(o):\n    # JSON'a uygun olmayan her şeyi okunabilir stringe çevir\n    # (ör. function, Path, set, custom objeler vs.)\n    name = getattr(o, \"__name__\", None)\n    if name:\n        return name\n    try:\n        return str(o)\n    except Exception:\n        return f\"<non-serializable {type(o).__name__}>\"\n\ndef main():\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"-s\", \"--script\", required=True, help=\"Fluxion script path (.flx)\")\n    ap.add_argument(\"-D\", \"--define\", action=\"append\", default=[],\n                    help=\"Predefine variables (key=value or flag)\")\n    args = ap.parse_args()\n\n    vars_dict: dict[str, object] = {}\n    for item in args.define:\n        if \"=\" in item:\n            k, v = item.split(\"=\", 1)\n            vars_dict[k] = v\n        else:\n            vars_dict[item] = True\n\n    runner = RunnerV2()\n    res = runner.run_file(args.script, variables=vars_dict)\n\n    json.dump(res, sys.stdout, ensure_ascii=False, indent=2, default=_json_default)\n    sys.stdout.write(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":1189},"fluxion/__main__.py":{"content":"from .cli import main\nif __name__ == \"__main__\":\n    main()\n","size_bytes":60}},"version":2}